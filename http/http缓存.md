### 缓存是什么?

把一些不需要每次都重新下载获取的资源保存起来（浏览器会根据服务器返回的 Cache-Control 判断请求的资源是否可以缓存下来），再次 http 请求时，浏览器会先在本地缓存中找这个资源，如果资源已经被存储它会拦截请求，返回存储的资源，而不会去服务器重新下载。

### 为什么需要缓存

1. 网络请求的加载相对于 cpu 的计算和渲染是很慢的，因此减少网络请求数量可以优化网页性能。 另外，网络请求是不稳定的，这使得页面加载显示具有不稳定性，使用缓存的话有利于页面稳定性。
2. 减少网络带宽消耗，降低运营成本。
3. 减少对源服务器的请求，间接降低服务器的压力。

### 哪些资源可以被缓存?

常规静态资源缓存 js/css/img。html 模板和业务数据，很少缓存（有的需求当然也是可以缓存的）。像是这种常规的静态资源加上 hash 名打包后是不会修改的。webpack 打包的时候生成的 hash 哈希值是根据文件内容生成的。文件内容改变，重新打包生成的 hash 值也会改变。

### http 强制缓存 Cache-Control

Cache-Control 在 Response Headers 中，用来控制强制缓存，需要服务端进行设置。
客户端根据 Cache-Control 判断请求的资源用本地缓存还是从服务端获取。

例如 Cache-Control：max-age=31536000(单位是秒）

cache-control 的值：

1. max-age 设置缓存最大过期时间
2. no-cache 不用本地强制缓存，正常向服务端请求资源，由服务器端来处理
3. no-store 不用本地强制缓存，也不用服务端的缓存措施（协商缓存），直接由服务端返回新资源
4. private 只允许最终用户做缓存
5. public 用户和中间代理都能缓存

max-age 和 no-cache 最常用

Expires 与 Cache-Control：

- 同在 Reponse Headers 中
- 同为控制缓存过期
- Expires 标准比较老已被 Cache-Control 代替

### http 缓存-协商缓存（也叫对比缓存）

- 服务端缓存策略（资源到了服务端由服务端判断能不能用客户端的缓存，不是资源被缓存到服务端还是缓存到本地。）
- 服务器通过资源标识判断客户端资源是否和服务器端资源一样
- 一致则返回 304（告知客户端用本地资源即可），否则返回 200 和最新的资源（返回 304 状态码请求体积非常小，没有文件返回，效率非常高）

具体步骤：

1. 浏览器初次请求资源
2. 服务器返回资源和资源标识（Etag 或 Last-Modified，资源标识在 Response Header 中）
3. 浏览器再次请求，带着资源标识（资源标识如果是 Etag 则再次请求时，Request Header 中会带着 if-None-Match 请求头，值是上一步服务器返回的 Etag 的值。资源标识如果是 Last-Modified 则再次请求时，Request Header 中会带着 if-Modified-Since 请求头，值是上一步服务器返回的 Last-Modified 的值。）
4. 服务器通过资源标识判断客户端资源是否和服务器端资源一样。一样返回 304，不一样则返回新的资源和资源标识（Etag 或 Last-Modified）

资源标识在 Response Header 中，有两种：

1. Last-Modified 资源的最后修改时间
2. Etag 资源的唯一标识（一个字符串），根据资源文件生成唯一的标识，资源不变生成的 Etag 不变。

Last-Modified 和 Etag

- 优先使用 Etag
- Last-Modified 只能精确到秒级
- 如果资源被重复生成，而内容不变，这时使用 Etag 更精确
